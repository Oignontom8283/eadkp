
# Le RGB 565

> Le format RGB 565 est un format de couleur sur 16 bits, utilisÃ© principalement
> dans les systÃ¨mes embarquÃ©s et les Ã©crans Ã  mÃ©moire limitÃ©e.
> Cette page explique son fonctionnement, ses avantages et comment convertir
> depuis et vers le RGB 888.


## DiffÃ©renciation


Lorsqu'on parle de RGB, sans prÃ©cision, on fait gÃ©nÃ©ralement rÃ©fÃ©rence au format RGB 888.
Mais alors, qu'est-ce que le RGB 888 ?

Le RGB 888, c'est le fameux format de couleur oÃ¹ l'on reprÃ©sente la couleur grÃ¢ce au Rouge, Vert et Bleu, chacun quantifiÃ© de 0 Ã  255.

Exemple avec du CSS :
```css
background-color: rgb(255, 0, 0); /* Rouge */
background-color: rgb(0, 255, 0); /* Vert */
background-color: rgb(0, 0, 255); /* Bleu */
background-color: rgb(255, 255, 0); /* Jaune */
background-color: rgb(0, 255, 255); /* Cyan */
background-color: rgb(255, 0, 255); /* Magenta */
background-color: rgb(255, 255, 255); /* Blanc */
background-color: rgb(0, 0, 0); /* Noir */
etc...
```

Le RGB normal (donc le RGB 888) a donc un total de `256 x 256 x 256 = 16 777 216` couleurs possibles.


### Pourquoi le 888 ?

Le RGB 888 signifie que chacune des trois couleurs (Rouge, Vert, Bleu) est encodÃ©e en binaire sur 8 bits (1 octet), soit `2^8 = 256` valeurs possibles (de 0 Ã  255).

Chaque couleur utilise donc 8 bits, d'oÃ¹ le nom RGB 888 (8 bits pour le Rouge, 8 bits pour le Vert, 8 bits pour le Bleu).
Ce qui fait un total de `8 + 8 + 8 = 24 bits` par pixel, soit 3 octets par pixel.


## RGB 565

Comme on l'a vu, le RGB 888 utilise **8 bits par couleur**. Le RGB 565, c'est le mÃªme principe, mais avec une rÃ©partition **diffÃ©rente** des bits.

En premier lieu, **5** bits pour encoder le Rouge en binaire, **6** bits pour le Vert, et **5** bits pour le Bleu. On a donc `2^5 = 32` valeurs possibles pour
le Rouge et le Bleu, et `2^6 = 64` valeurs possibles pour le Vert. Soit un total de `32 x 64 x 32 = 65 536` couleurs possibles.


## Avantages et inconvÃ©nients

Vous allez me dire : "Mais 65 536 couleurs, c'est rien du tout comparÃ© aux 16 millions de couleurs du RGB 888 !".
Et OUI, c'est vrai, mais pour beaucoup de cas d'utilisation, avoir moins de profondeur de couleur est acceptable, surtout quand on compare avec l'Ã©norme avantage du RGB 565.
Vous allez comprendre.

Le RGB 565 utilise donc `5 bits + 6 bits + 5 bits = 16 bits` par pixel, soit **2 octets** par pixel. Le RGB 888, lui, utilise **24 bits** par pixel, soit **3 octets** par pixel.

UN octet de diffÃ©rence par pixel ! Alors oui, pour des ordinateurs avec 8, 16, 32 Go de RAM, 1 octet de plus ou de moins, c'est rien.
Mais sur des systÃ¨mes embarquÃ©s, qui ont 256 Mo, 512 Mo, ou mÃªme 256 Ko de RAM (comme dans notre cas, avec la Numworks), chaque octet compte !


Faisons un petit calcul rapide :
```bat
La calculatrice Numworks a un Ã©cran de 320x240 pixels.
320 x 240 = 76 800 pixels
En RGB 888 : 76 800 pixels x 3 octets = 230 400 octets (~225 Ko)
En RGB 565 : 76 800 pixels x 2 octets = 153 600 octets (~150 Ko)

Soit une diffÃ©rence de 76 800 octets (~75 Ko).
Ce qui correspond Ã  environ 30% de RAM en moins utilisÃ©e !
```

> Alors oui, les connaisseurs en Ã©lectronique embarquÃ©e diront qu'effectivement, ce n'est pas vÃ©ritablement la RAM de la calculatrice qui est impactÃ©e,
mais plutÃ´t la VRAM (Video RAM) de l'Ã©cran lui-mÃªme (uniquement dÃ©diÃ©e Ã  l'affichage). Mais le principe reste le mÃªme : moins on utilise de mÃ©moire, mieux c'est.
Et puis, cela rend aussi les Ã©crans moins chers !


## Pourquoi 5, 6, 5 bits ?

Pourquoi pas 555 ou 666 bits alors ?

Vous l'aurez remarquÃ©, `5 + 6 + 5 = 16 bits`, ce qui fait un total rond et compact de 2 octets par pixel.
Et c'est bien plus pratique de stocker des choses sur des octets entiers. Sinon il faudrait faire du bit-packing, et c'est plus compliquÃ© Ã  gÃ©rer et plus de calculs Ã  faire.

Donc pourquoi c'est le **vert** qui a **6 bits** et pas le rouge ou le bleu ?
Car l'Å“il humain est plus sensible au vert qu'aux autres couleurs. Donc vu qu'on a moins de profondeur de couleur,
on privilÃ©gie la couleur la plus importante pour l'Å“il humain. Ã‡a permet d'avoir un meilleur rendu visuel,
dÃ©jÃ  qu'on a moins de couleurs, autant les rendre moins ternes que possible !


### Exemple :
En RGB 888 `(66/255, 138/255, 245/255)` (une belle teinte de bleu clair) devient en RGB 565 `(8/31, 34/63, 30/31)`. C'est quasiment indiscernable !
> Note : Les valeurs entre parenthÃ¨ses reprÃ©sentent les valeurs entiÃ¨res pour chaque composante de couleur (Rouge, Vert, Bleu).

En RGB 888 :
![checkerboard](./assets/square_888.svg)

En RGB 565 :
![checkerboard](./assets/square_565.svg)

## Encodage binaire

L'encodage binaire d'une couleur en RGB 565 se fait en concatÃ©nant les bits de chaque couleur dans l'ordre suivant : Rouge (5 bits), Vert (6 bits), Bleu (5 bits).

```
RED    GREEN   BLUE
01000  100010  11110
=8     =34     =30
```

Donc chaque pixel rentre parfaitement dans un entier non signÃ© sur 16 bits (`u16`).

Voir le [SchÃ©ma sur le fonctionnement du format de fichier EIF1](./schemas/eif1-format-v3.jpg) pour une reprÃ©sentation visuelle plus claire.

Sinon, voici un petit site web sympa pour sÃ©lectionner et visualiser des couleurs en RGB 565 : https://rgbcolorpicker.com/565

## Conversion

### RGB 888 -> RGB 565

Pour convertir une couleur du format RGB 888 au format RGB 565, c'est assez simple. Il suffit de rÃ©duire les 8 bits en 5 ou 6 bits selon la couleur.
On va devoir couper les bits de poids faible (les bits les moins significatifs (**Ã  droite**)), en gros, on retire de la prÃ©cision.

Exemple en Rust :
```rs
fn rgb888_to_rgb565(r: u8, g: u8, b: u8) -> u16 {
    let r5 = (r >> 3) as u16; // Prendre les 5 bits de poids fort du rouge
    let g6 = (g >> 2) as u16; // Prendre les 6 bits de poids fort du vert
    let b5 = (b >> 3) as u16; // Prendre les 5 bits de poids fort du bleu

    (r5 << 11) | (g6 << 5) | b5 // Combiner les bits dans un seul entier u16
}
// rgb888_to_rgb565(66, 138, 245) => 0b01000_100010_11110 = 0x442E
```
On renvoie un entier non signÃ© sur 16 bits (`u16`) reprÃ©sentant la couleur en RGB 565. Et non directement les 3 composantes sÃ©parÃ©es,
car tout simplement, Ã§a sert Ã  stocker la couleur dans un seul u16, plutÃ´t que dans 3 u8 sÃ©parÃ©s.

Et un petit exemple en Python (pour les amateurs de Python) :
```py
def rgb888_to_rgb565(r, g, b):
    r5 = r >> 3  # Prendre les 5 bits de poids fort du rouge
    g6 = g >> 2  # Prendre les 6 bits de poids fort du vert
    b5 = b >> 3  # Prendre les 5 bits de poids fort du bleu
    return (r5 << 11) | (g6 << 5) | b5  # Combiner les bits dans un seul entier u16

# rgb888_to_rgb565(66, 138, 245) => 0b01000_100010_11110 = 0x442E
```
Oui, Python permet aussi de faire des opÃ©rations bit Ã  bit, ce n'est pas que du scripting ! (Surprenant hein ?)


### RGB 565 -> RGB 888

On est sur le principe inverse. On va devoir Ã©tendre les 5 ou 6 bits en 8 bits. On rajoute des bits de poids faible (les bits les moins significatifs (**Ã  droite**)). En gros, des zÃ©ros.

Exemple en Rust :
```rs
fn rgb565_to_rgb888(rgb565: u16) -> (u8, u8, u8) {
    let r5 = (rgb565 >> 11) & 0x1F; // Extraire les 5 bits du rouge
    let g6 = (rgb565 >> 5) & 0x3F;  // Extraire les 6 bits du vert
    let b5 = rgb565 & 0x1F;         // Extraire les 5 bits du bleu

    let r8 = (r5 << 3) | (r5 >> 2); // Ã‰tendre Ã  8 bits
    let g8 = (g6 << 2) | (g6 >> 4); // Ã‰tendre Ã  8 bits
    let b8 = (b5 << 3) | (b5 >> 2); // Ã‰tendre Ã  8 bits

    (r8 as u8, g8 as u8, b8 as u8)
}
```
On renvoie un tuple de 3 entiers non signÃ©s sur 8 bits (`u8`) reprÃ©sentant les composantes Rouge, Vert et Bleu en RGB 888. Oui, lÃ  on a le droit de renvoyer les 3 composantes sÃ©parÃ©es ğŸ¤¨.

Et Ã  nouveau un petit exemple en Python :
```py
def rgb565_to_rgb888(rgb565):
    r5 = (rgb565 >> 11) & 0x1F  # Extraire les 5 bits du rouge
    g6 = (rgb565 >> 5) & 0x3F   # Extraire les 6 bits du vert
    b5 = rgb565 & 0x1F          # Extraire les 5 bits du bleu

    r8 = (r5 << 3) | (r5 >> 2)  # Ã‰tendre Ã  8 bits
    g8 = (g6 << 2) | (g6 >> 4)  # Ã‰tendre Ã  8 bits
    b8 = (b5 << 3) | (b5 >> 2)  # Ã‰tendre Ã  8 bits

    return (r8, g8, b8)

# rgb565_to_rgb888(0x442E) => (66, 136, 248)
```


## Ressources supplÃ©mentaires

Si vous voulez en savoir plus sur le RGB 565, voici quelques ressources intÃ©ressantes :
- [Wikipedia - RGB565](https://en.wikipedia.org/wiki/RGB_color_space#RGB_565)
- [RGB565 Color Conversion - Stack Overflow](https://stackoverflow.com/questions/16452383/rgb565-color-conversion)

Tutoriel sur les opÃ©rations bit Ã  bit en Rust : [Rust Programming Tutorial #31 - bitwise operators](https://www.youtube.com/watch?v=qYTQ1hUlva4)


## TL;DR
- RGB 888 : 24 bits par pixel (3 octets), un octet par couleur, 16 millions de couleurs.
- RGB 565 : 16 bits par pixel (2 octets), 5 bits pour le rouge, 6 bits pour le vert, 5 bits pour le bleu, 65 mille couleurs.
- IdÃ©al pour les systÃ¨mes embarquÃ©s avec peu de mÃ©moire, comme la calculatrice Numworks.

Conversion :
- RGB 888 -> 565 : DÃ©caler les bits de poids faible (droite) et combiner sur un u16.
- RGB 565 -> 888 : Extraire les bits et Ã©tendre en ajoutant des bits de poids faible (droite).