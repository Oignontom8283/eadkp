
# Le RGB 565

> Le format RGB 565 est un format de couleur sur 16 bits, utilis√© principalement
> dans les syst√®mes embarqu√©s et les √©crans √† m√©moire limit√©e.
> Cette page explique son fonctionnement, ses avantages et comment convertir
> depuis et vers le RGB 888.


## Diff√©renciation


Lorsqu'on parle de RGB, sans pr√©cision, on fait g√©n√©ralement r√©f√©rence au format RGB 888.
Mais alors, qu'est-ce que le RGB 888 ?

Le RGB 888, c'est le fameux format de couleur o√π l'on repr√©sente la couleur gr√¢ce au Rouge, Vert et Bleu, chacun quantifi√© de 0 √† 255.

Exemple avec du CSS :
```css
background-color: rgb(255, 0, 0); /* Rouge */
background-color: rgb(0, 255, 0); /* Vert */
background-color: rgb(0, 0, 255); /* Bleu */
background-color: rgb(255, 255, 0); /* Jaune */
background-color: rgb(0, 255, 255); /* Cyan */
background-color: rgb(255, 0, 255); /* Magenta */
background-color: rgb(255, 255, 255); /* Blanc */
background-color: rgb(0, 0, 0); /* Noir */
etc...
```

Le RGB normal (donc le RGB 888) a donc un total de `256 x 256 x 256 = 16 777 216` couleurs possibles.


### Pourquoi le 888 ?

Le RGB 888 signifie que chacune des trois couleurs (Rouge, Vert, Bleu) est encod√©e en binaire sur 8 bits (1 octet), soit `2^8 = 256` valeurs possibles (de 0 √† 255).

Chaque couleur utilise donc 8 bits, d'o√π le nom RGB 888 (8 bits pour le Rouge, 8 bits pour le Vert, 8 bits pour le Bleu).
Ce qui fait un total de `8 + 8 + 8 = 24 bits` par pixel, soit 3 octets par pixel.


## RGB 565

Comme on l'a vu, le RGB 888 utilise **8 bits par couleur**. Le RGB 565, c'est le m√™me principe, mais avec une r√©partition **diff√©rente** des bits.

En premier lieu, **5** bits pour encoder le Rouge en binaire, **6** bits pour le Vert, et **5** bits pour le Bleu. On a donc `2^5 = 32` valeurs possibles pour
le Rouge et le Bleu, et `2^6 = 64` valeurs possibles pour le Vert. Soit un total de `32 x 64 x 32 = 65 536` couleurs possibles.


## Avantages et inconv√©nients

Vous allez me dire : "Mais 65 536 couleurs, c'est rien du tout compar√© aux 16 millions de couleurs du RGB 888 !".
Et OUI, c'est vrai, mais pour beaucoup de cas d'utilisation, avoir moins de profondeur de couleur est acceptable, surtout quand on compare avec l'√©norme avantage du RGB 565.
Vous allez comprendre.

Le RGB 565 utilise donc `5 bits + 6 bits + 5 bits = 16 bits` par pixel, soit **2 octets** par pixel. Le RGB 888, lui, utilise **24 bits** par pixel, soit **3 octets** par pixel.

UN octet de diff√©rence par pixel ! Alors oui, pour des ordinateurs avec 8, 16, 32 Go de RAM, 1 octet de plus ou de moins, c'est rien.
Mais sur des syst√®mes embarqu√©s, qui ont 256 Mo, 512 Mo, ou m√™me 256 Ko de RAM (comme dans notre cas, avec la Numworks), chaque octet compte !


Faisons un petit calcul rapide :
```bat
La calculatrice Numworks a un √©cran de 320x240 pixels.
320 x 240 = 76 800 pixels
En RGB 888 : 76 800 pixels x 3 octets = 230 400 octets (~225 Ko)
En RGB 565 : 76 800 pixels x 2 octets = 153 600 octets (~150 Ko)

Soit une diff√©rence de 76 800 octets (~75 Ko).
Ce qui correspond √† environ 30% de RAM en moins utilis√©e !
```

> Alors oui, les connaisseurs en √©lectronique embarqu√©e diront qu'effectivement, ce n'est pas v√©ritablement la RAM de la calculatrice qui est impact√©e,
mais plut√¥t la VRAM (Video RAM) de l'√©cran lui-m√™me (uniquement d√©di√©e √† l'affichage). Mais le principe reste le m√™me : moins on utilise de m√©moire, mieux c'est.
Et puis, cela rend aussi les √©crans moins chers !


## Pourquoi 5, 6, 5 bits ?

Pourquoi pas 555 ou 666 bits alors ?

Vous l'aurez remarqu√©, `5 + 6 + 5 = 16 bits`, ce qui fait un total rond et compact de 2 octets par pixel.
Et c'est bien plus pratique de stocker des choses sur des octets entiers. Sinon il faudrait faire du bit-packing, et c'est plus compliqu√© √† g√©rer et plus de calculs √† faire.

Donc pourquoi c'est le **vert** qui a **6 bits** et pas le rouge ou le bleu ?
Car l'≈ìil humain est plus sensible au vert qu'aux autres couleurs. Donc vu qu'on a moins de profondeur de couleur,
on privil√©gie la couleur la plus importante pour l'≈ìil humain. √áa permet d'avoir un meilleur rendu visuel,
d√©j√† qu'on a moins de couleurs, autant les rendre moins ternes que possible !


### Exemple :
En RGB 888 `(66/255, 138/255, 245/255)` (une belle teinte de bleu clair) devient en RGB 565 `(8/31, 34/63, 30/31)`. C'est quasiment indiscernable !
> Note : Les valeurs entre parenth√®ses repr√©sentent les valeurs enti√®res pour chaque composante de couleur (Rouge, Vert, Bleu).

En RGB 888 :
![checkerboard](./assets/square_888.svg)

En RGB 565 :
![checkerboard](./assets/square_565.svg)

## Encodage binaire

L'encodage binaire d'une couleur en RGB 565 se fait en concat√©nant les bits de chaque couleur dans l'ordre suivant : Rouge (5 bits), Vert (6 bits), Bleu (5 bits).

```
RED    GREEN   BLUE
01000  100010  11110
=8     =34     =30
```

Donc chaque pixel rentre parfaitement dans un entier non sign√© sur 16 bits (`u16`).

Voir le [Sch√©ma sur le fonctionnement du format de fichier EIF1](./schemas/eif1-format-v3.jpg) pour une repr√©sentation visuelle plus claire.

Sinon, voici un petit site web sympa pour s√©lectionner et visualiser des couleurs en RGB 565 : https://rgbcolorpicker.com/565

## Conversion

### RGB 888 <-> RGB 565

Pour convertir une couleur du format RGB 888 au format RGB 565, c'est assez simple. Il suffit de r√©duire les 8 bits en 5 ou 6 bits selon la couleur.
On va devoir couper les bits de poids faible (les bits les moins significatifs (**√† droite**)), en gros, on retire de la pr√©cision.

Exemple en Rust :
```rs
fn rgb888_to_rgb565(r: u8, g: u8, b: u8) -> u16 {
    let r5 = (r >> 3) as u16; // Prendre les 5 bits de poids fort du rouge
    let g6 = (g >> 2) as u16; // Prendre les 6 bits de poids fort du vert
    let b5 = (b >> 3) as u16; // Prendre les 5 bits de poids fort du bleu

    (r5 << 11) | (g6 << 5) | b5 // Combiner les bits dans un seul entier u16
}
// rgb888_to_rgb565(66, 138, 245) => 0b01000_100010_11110 = 0x442E
```
On renvoie un entier non sign√© sur 16 bits (`u16`) repr√©sentant la couleur en RGB 565. Et non directement les 3 composantes s√©par√©es,
car tout simplement, √ßa sert √† stocker la couleur dans un seul u16, plut√¥t que dans 3 u8 s√©par√©s.

Et un petit exemple en Python (pour les amateurs de Python) :
```py
def rgb888_to_rgb565(r, g, b):
    r5 = r >> 3  # Prendre les 5 bits de poids fort du rouge
    g6 = g >> 2  # Prendre les 6 bits de poids fort du vert
    b5 = b >> 3  # Prendre les 5 bits de poids fort du bleu
    return (r5 << 11) | (g6 << 5) | b5  # Combiner les bits dans un seul entier u16

# rgb888_to_rgb565(66, 138, 245) => 0b01000_100010_11110 = 0x442E
```
Oui, Python permet aussi de faire des op√©rations bit √† bit, ce n'est pas que du scripting ! (Surprenant hein ?)


### RGB 565 -> RGB 888

On est sur le principe inverse. On va devoir √©tendre les 5 ou 6 bits en 8 bits. On rajoute des bits de poids faible (les bits les moins significatifs (**√† droite**)). En gros, des z√©ros.

Exemple en Rust :
```rs
fn rgb565_to_rgb888(rgb565: u16) -> (u8, u8, u8) {
    let r5 = (rgb565 >> 11) & 0x1F; // Extraire les 5 bits du rouge
    let g6 = (rgb565 >> 5) & 0x3F;  // Extraire les 6 bits du vert
    let b5 = rgb565 & 0x1F;         // Extraire les 5 bits du bleu

    let r8 = (r5 << 3) | (r5 >> 2); // √âtendre √† 8 bits
    let g8 = (g6 << 2) | (g6 >> 4); // √âtendre √† 8 bits
    let b8 = (b5 << 3) | (b5 >> 2); // √âtendre √† 8 bits

    (r8 as u8, g8 as u8, b8 as u8)
}
```
On renvoie un tuple de 3 entiers non sign√©s sur 8 bits (`u8`) repr√©sentant les composantes Rouge, Vert et Bleu en RGB 888. Oui, l√† on a le droit de renvoyer les 3 composantes s√©par√©es ü§®.

Et √† nouveau un petit exemple en Python :
```py
def rgb565_to_rgb888(rgb565):
    r5 = (rgb565 >> 11) & 0x1F  # Extraire les 5 bits du rouge
    g6 = (rgb565 >> 5) & 0x3F   # Extraire les 6 bits du vert
    b5 = rgb565 & 0x1F          # Extraire les 5 bits du bleu

    r8 = (r5 << 3) | (r5 >> 2)  # √âtendre √† 8 bits
    g8 = (g6 << 2) | (g6 >> 4)  # √âtendre √† 8 bits
    b8 = (b5 << 3) | (b5 >> 2)  # √âtendre √† 8 bits

    return (r8, g8, b8)

# rgb565_to_rgb888(0x442E) => (66, 136, 248)
```


## Ressources suppl√©mentaires

Si vous voulez en savoir plus sur le RGB 565, voici quelques ressources int√©ressantes :
- [Wikipedia - RGB565](https://en.wikipedia.org/wiki/RGB_color_space#RGB_565)
- [RGB565 Color Conversion - Stack Overflow](https://stackoverflow.com/questions/16452383/rgb565-color-conversion)

Tutoriel sur les op√©rations bit √† bit en Rust : [Rust Programming Tutorial #31 - bitwise operators](https://www.youtube.com/watch?v=qYTQ1hUlva4)


## TL;DR
- RGB 888 : 24 bits par pixel (3 octets), un octet par couleur, 16 millions de couleurs.
- RGB 565 : 16 bits par pixel (2 octets), 5 bits pour le rouge, 6 bits pour le vert, 5 bits pour le bleu, 65 mille couleurs.
- Id√©al pour les syst√®mes embarqu√©s avec peu de m√©moire, comme la calculatrice Numworks.

Conversion :
- RGB 888 -> 565 : D√©caler les bits de poids faible (droite) et combiner sur un u16.
- RGB 565 -> 888 : Extraire les bits et √©tendre en ajoutant des bits de poids faible (droite).